---
site: workflowr::wflow_site
title: "SQANTI"
output:
  workflowr::wflow_html:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: textmate
    code_folding: show
---



# SQANTI 
Will do SQANTI analysis from the txt file. 
```{r setup, echo=TRUE, warning=FALSE}
library(Seurat)
library(rtracklayer)
library(tidyr)
library("stringr")
library("biomaRt")
library("here")
library("dplyr")
library(GenomicFeatures)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg38)
library(ggplot2)
```

```{r, include=TRUE}
obj <- qs2::qs_read(here("output","seurat_objects", "seurat_filt_harm_annotated_iso.qs"))
DefaultAssay(obj) <- "iso"
obj <- JoinLayers(obj)
```

```{r, echo=TRUE, eval=FALSE}
# 1. Load Seurat object and get the raw feature names
### obj     <- readRDS("path/to/your_seurat_object.rds")
DefaultAssay(obj) <- "iso"
raw_feats <- rownames(obj)  
head(raw_feats)

# 2. Extract just the transcript IDs (the ENST part)
transcript_ids <- sapply(strsplit(raw_feats, "-"), `[`, 1)
head(transcript_ids)


# 3. Import GTF and filter on transcript_id
gtf        <- import("/data/scratch/users/yairp/Kolf2.1_FLAMESv2/outs/Bambu_NDR_0.75/remove_unknownstrand.gtf")
filtered_gtf <- gtf[mcols(gtf)$transcript_id %in% transcript_ids]

#inspect elements 
as.data.frame(gtf) -> df.gtf
as.data.frame(filtered_gtf) -> df.filtered.gtf

# 5. Export just the transcript-based subset for SQANTI
export(filtered_gtf, "../output/ref_file/filtered_for_sqanti.gtf")

```

## R 
Create additional figures as required
create a a big DF with all the data we will need for plotting 
```{r , echo=FALSE}

counts <- AggregateExpression(
  obj, 
  assays = "iso", 
  return.seurat = FALSE,
  group.by = c("BroadType")
)

as.data.frame(counts) -> df

row.names(df) -> df$gene

#split transcript ids
df <- df %>% separate(gene, into = c("transcript_id", "gene_id"), sep = "-",  extra = "merge")
df$transcript_id <- sub("\\..*", "", df$transcript_id)

###lets read in SQANTI classifiaction data 
classifications <- read.table(here("output", "SQANTI_outs", "filtered_for_sqanti_classification.txt"), header = T)
classifications$isoform <- sub("\\..*", "", classifications$isoform)

  merged_data <- merge(df, classifications, 
                     by.x = "transcript_id", 
                     by.y = "isoform", 
                     all.x = TRUE)
  
  merged_data <- merged_data %>% dplyr::filter(!is.na(structural_category)) %>% filter(!str_detect(gene_id, "BambuGene"))
  
# Retrieve gene biotype from Ensemble
  mart <- useMart(biomart = "ensembl", 
                 dataset = "hsapiens_gene_ensembl") # Change this to another mirror if available
  
attrs <- c(
  # Transcript identifiers & basic flags
  "ensembl_transcript_id",
  "transcript_is_canonical",
  "transcript_biotype")
  
  biotype_info_transcript <- getBM(attributes = attrs, filters = 'ensembl_transcript_id',
                                   values = merged_data$transcript_id,
                                   mart = mart)
  
  merged_data <- merge(merged_data, biotype_info_transcript, 
                     by.x = "transcript_id", 
                     by.y = "ensembl_transcript_id", 
                     all.x = TRUE)
```   

## Here I want to add number of exons - and GC content 
## not exactly sure whats gone wrong here - some isoforms have NA ???????
```{r}  
# 1. Import your GTF and build a TxDb
txdb <- makeTxDbFromGFF(here("output", "ref_file", "filtered_for_sqanti.gtf"), format="gtf")

# 2. Get exons grouped by transcript
exons_list <- exonsBy(txdb, by="tx", use.names=TRUE)
#   names(exons_list) are your ensembl transcript IDs

# 3. Count exons per transcript
exon_counts <- elementNROWS(exons_list)
#   a named integer vector: names = transcript IDs, values = exon counts

# 2) Extract transcript sequences
tx_seqs <- extractTranscriptSeqs(Hsapiens, txdb)
# At this point names(tx_seqs) are “1”,“2”,…  

# 3) Re‐assign the correct names and ensure ordering matches exon_counts
tx_ids_raw <- names(exon_counts)
tx_ids     <- sub("\\.\\d+$", "", tx_ids_raw)   # remove version suffix
if(length(tx_seqs) != length(tx_ids)) {
  stop("Transcript count mismatch between exon_counts and tx_seqs")
}
names(tx_seqs) <- tx_ids
tx_seqs       <- tx_seqs[tx_ids]

# 4) Compute GC content (now names are ENST IDs)
gc_matrix   <- letterFrequency(tx_seqs, letters = c("G","C"), as.prob = TRUE)
gc_content  <- rowSums(gc_matrix)              # preserves names

tx_length  <- width(tx_seqs)

# 4) Turn both vectors into data.frames
df <- data.frame(
  ensembl_transcript_id = names(exon_counts),
  exon_count            = as.integer(exon_counts),
  gc_content            = as.numeric(gc_content),
  transcript_length     = as.integer(tx_length),
  stringsAsFactors      = FALSE
)

df$ensembl_transcript_id <- sub("\\..*", "", df$ensembl_transcript_id)
## add this info to the SQANTI object

merged_data <- merge(merged_data, df, 
                     by.x = "transcript_id", 
                     by.y = "ensembl_transcript_id", 
                     all.x = TRUE)
  
```  


```{r}   
# Reshape the data to long format
long_data <- merged_data %>%
  pivot_longer(cols = starts_with("iso."), 
               names_to = "cell_type", 
               values_to = "expression")

# Calculate the total and canonical isoforms by gene and cell type
proportion_data <- long_data %>%
  group_by(cell_type) %>%
  summarise(
    total_isoforms = sum(expression, na.rm = TRUE),
    canonical_isoforms = sum(expression[transcript_is_canonical == 1], na.rm = TRUE),
    non_canonical_isoforms = sum(expression[transcript_is_canonical == 0 | is.na(transcript_is_canonical)], na.rm = TRUE),
    canonical_proportion = canonical_isoforms / total_isoforms
  )


# Handle cases where total_isoforms == 0 to avoid division by zero
proportion_data <- proportion_data %>%
  mutate(canonical_proportion = ifelse(total_isoforms > 0, canonical_proportion, NA))

# Calculate non-canonical proportions
proportion_data <- proportion_data %>%
  mutate(non_canonical_proportion = 1 - canonical_proportion)

# Reshape the data for the stacked bar plot
proportion_data_long <- reshape2::melt(proportion_data, id.vars = "cell_type", 
                             measure.vars = c("canonical_proportion", "non_canonical_proportion"),
                             variable.name = "isoform_type", 
                             value.name = "proportion")

# Create the stacked bar plot with canonical isoforms at the bottom
ggplot(proportion_data_long, aes(x = cell_type, y = proportion, fill = factor(isoform_type, levels = c("non_canonical_proportion", "canonical_proportion")))) +
  geom_bar(stat = "identity", color = "black", size = 0.3) +  # Stacked bars with black outline
  geom_text(aes(label = paste0(round(proportion * 100, 1), "%")),
            position = position_stack(vjust = 0.5), color = "white", size = 3.5) +  # Percentage labels in bar
  scale_fill_manual(values = c("canonical_proportion" = "grey", 
                               "non_canonical_proportion" = "black"), 
                    name = "Isoform Type",  # Legend title
                    labels = c("canonical_proportion" = "Canonical Isoforms", 
                               "non_canonical_proportion" = "Non-Canonical Isoforms")) +  # Legend labels
  labs(title = "Proportion of Canonical vs Non-Canonical \n expression per Cell Type",
       x = "Cell Type",
       y = "Proportion") +
  theme_minimal(base_size = 14) +  # Base font size
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12, face = "bold"),  # Rotate and bold x-axis labels
        axis.text.y = element_text(size = 12),  # Y-axis label size
        plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  # Center and bold title
        legend.position = "right",  # Show legend on the right
        panel.grid.major = element_line(size = 0.2),  # Subtle grid lines
        panel.grid.minor = element_blank())  # Remove minor grid lines


```
```{r}
proportion_data_long$isoform_type <- factor(
  proportion_data_long$isoform_type,
  levels = c("canonical_proportion", "non_canonical_proportion")
)

# Create the pie charts faceted by cell_type
pie_chart <- ggplot(proportion_data_long, 
       aes(x = "", 
           y = proportion, 
           fill = isoform_type)) +
  geom_col(color = "black", size = 0.3, width = 1) +            # Solid bar that becomes pie slice
  coord_polar(theta = "y") +                                     # Turn bar into pie
  facet_wrap(~ cell_type, ncol = 6) +                            # One pie per cell type, 3 per row
  geom_text(aes(label = ifelse(proportion > 0.05,
                               paste0(round(proportion * 100, 1), "%"),
                               "")),
            position = position_stack(vjust = 0.5),
            color = "white",
            size = 3) +                                           # Only label slices > 5%
  scale_fill_manual(
    values = c(
      "canonical_proportion"      = "grey",
      "non_canonical_proportion"  = "black"
    ),
    name   = NULL,  # no legend title
    labels = c(
      "canonical_proportion"     = "Canonical",
      "non_canonical_proportion" = "Non-Canonical"
    )
  ) +
  labs(
    title = "Canonical vs Non-Canonical Isoform Proportions\nby Cell Type"
  ) +
  theme_void(base_size = 14) +  # clean theme for pies
  theme(
    plot.title        = element_text(hjust = 0.5, size = 16, face = "bold"),
    strip.text        = element_text(size = 10, face = "bold"),
    strip.placement   = "outside",
    legend.position   = "bottom",
    legend.text       = element_text(size = 12),
    plot.margin       = margin(10, 10, 10, 10)
  )


pie_chart

```

## Including Plots

```{r}
#### by structural category
# Filter and modify structural categories
long_data_filt <- long_data %>%
  filter(!str_detect(gene_id, "BambuGene")) %>% # remove all bambu Gene
  filter(expression > 0) %>%
  distinct(transcript_id, .keep_all = TRUE) %>% ## see if duplicates make a different to props ###### they do VERY IMPORTANT #######
  dplyr::select(structural_category) %>%
  mutate(structural_category = case_when(
    structural_category %in% c("genic", "intergenic", "antisense", "fusion") ~ "other",
    TRUE ~ structural_category  # Keep remaining categories
  )) 

# Compute total proportions across all data (no per-cell-type grouping)
proportion_data <- long_data_filt %>%
  group_by(structural_category) %>%
  summarise(count = n()) %>%
  mutate(proportion = count / sum(count)) %>%  # Calculate overall proportion
  ungroup()

# Define structural category order
proportion_data$structural_category <- factor(proportion_data$structural_category,
                                              levels = c("full-splice_match","novel_in_catalog", "novel_not_in_catalog", 
                                                          "other"))

# Define a custom color palette
color_palette <- c(
  "other" = "#969696",
  "novel_not_in_catalog" = "coral2",
  "novel_in_catalog" = "#78C679",
  "full-splice_match" = "#6BAED6"
)

# Plot total proportion
SQANTI_plot <- ggplot(proportion_data, aes(x = structural_category, y = proportion, fill = structural_category)) +
  geom_bar(stat = "identity", color = "darkgrey", size = 0.3) +  # Stacked bars with outline
  scale_fill_manual(values = color_palette, name = "Structural Category") +
  labs(title = "Isoform Distribution by Structural Category",
       x = "Structural Category",
       y = "Proportion") +
  geom_text(aes(label = scales::percent(proportion, accuracy = 0.1)),
            position = position_stack(vjust = 0.5), size = 4, color = "black") +  # Label proportions
  theme_minimal(base_size = 14) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12, face = "bold"),  # Rotate x-axis labels at 45°
        axis.text.y = element_text(size = 12),  
        plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),  
        legend.position = "right",  
        panel.grid.major = element_line(size = 0.2),  
        panel.grid.minor = element_blank()) + ylim (0,1)


SQANTI_plot
```


```{r cars}
# Step 1: Filter out BambuGene, keep only expressed isoforms, and collapse duplicates by transcript_id
unique_isoforms <- long_data %>%
  filter(
    !str_detect(gene_id, "BambuGene"),  # drop any row whose gene_id contains "BambuGene"
    expression > 0                       # keep only isoforms with expression > 0
  ) %>%
  distinct(transcript_id, .keep_all = TRUE)  # keep only one row per transcript_id

# Step 2: Total number of unique isoforms (regardless of name)
total_isoforms <- unique_isoforms %>%
  summarise(n_total = n_distinct(transcript_id)) %>%
  pull(n_total)

# Step 3: Number of “novel” isoforms (those whose transcript_id begins with "BambuTx")
n_novel_isoforms <- unique_isoforms %>%
  filter(str_detect(transcript_id, "^BambuTx")) %>%
  summarise(n_novel = n_distinct(transcript_id)) %>%
  pull(n_novel)

# Print the results
cat("Total unique isoforms: ", total_isoforms, "\n")
cat("Novel isoforms (BambuTx*): ", n_novel_isoforms, "\n")


#~8% novel
```
so about 8% novel isofroms 


```{r}

# ------------------------------------------------------------------------------
# 1) First, compute “number of unique isoforms per gene”
#    We assume your data frame is named `long_data` and has at least these columns:
#      • gene_id
#      • transcript_id
#    If there are duplicates (e.g. the same isoform appearing multiple times), 
#    we collapse them so each (gene_id, transcript_id) pair counts only once.
# ------------------------------------------------------------------------------
isoforms_per_gene <- long_data %>%
  # keep only expressed isoforms, drop any “BambuGene” if desired:
  #filter(expression > 0, !str_detect(gene_id, "BambuGene")) %>%
  distinct(gene_id, transcript_id, .keep_all = TRUE) %>% 
  group_by(gene_id) %>%
  summarise(n_isoforms = n()) %>%
  ungroup()

# ------------------------------------------------------------------------------
# 2) Next, create discrete bins: “1”, “2–3”, “4–5”, “>=6”
# ------------------------------------------------------------------------------
isoforms_per_gene <- isoforms_per_gene %>%
  mutate(
    iso_bin = case_when(
      n_isoforms == 1            ~ "1",
      n_isoforms >= 2 & n_isoforms <= 3  ~ "2–3",
      n_isoforms >= 4 & n_isoforms <= 5  ~ "4–5",
      n_isoforms >= 6            ~ ">=6",
      TRUE                        ~ NA_character_
    )
  )

# ------------------------------------------------------------------------------
# 3) Calculate the percentage of genes falling into each bin
# ------------------------------------------------------------------------------
bin_counts <- isoforms_per_gene %>%
  group_by(iso_bin) %>%
  summarise(count = n()) %>%
  mutate(
    pct = count / sum(count) * 100
  ) %>%
  ungroup()

# (Optionally, re‐order the factor levels so the x‐axis appears in the desired order)
bin_counts$iso_bin <- factor(bin_counts$iso_bin, levels = c("1", "2–3", "4–5", ">=6"))

# ------------------------------------------------------------------------------
# 4) Define a custom color palette matching the example image:
#      • “1”     → orange
#      • “2–3”   → green
#      • “4–5”   → red (or coral)
#      • “>=6”  → gray
# ------------------------------------------------------------------------------

# ───────────────────────────────────────────────────────────────────────────────
# 4) Define the exact four‐color palette:
# ───────────────────────────────────────────────────────────────────────────────
my_colors <- c(
  "1"   = "#FFA500",   # orange
  "2–3" = "#228B22",   # green
  "1" = "#FA8072",   # coral/red
  ">=6" = "#808080"    # gray
)

# ───────────────────────────────────────────────────────────────────────────────
# 5) Create the bar plot with Y‐axis limited to 50:
# ───────────────────────────────────────────────────────────────────────────────
isoforms_per_gene <- ggplot(bin_counts, aes(x = iso_bin, y = pct, fill = iso_bin)) +
  geom_col(color = "black", size = 0.2, width = 0.8) +
  #scale_fill_manual(values = my_colors, guide = FALSE) +
  geom_text(aes(label = paste0(round(pct, 1), "%")),
            vjust = -0.5, size = 4, color = "black") +
  scale_y_continuous(limits = c(0, 50), expand = c(0, 0)) +
  labs(
    title = "Number of isoforms per gene",
    x = "Isoforms per Gene",
    y = "Genes, %"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title         = element_text(hjust = 0.5, face = "bold", size = 16),
    axis.title.x       = element_text(size = 14, face = "bold"),
    axis.title.y       = element_text(size = 14, face = "bold"),
    axis.text.x        = element_text(size = 12, face = "bold"),
    axis.text.y        = element_text(size = 12),
    panel.grid.major.x = element_blank(),
    panel.grid.minor   = element_blank(),
    legend.position    = "none"
  )

isoforms_per_gene
```



# Isofomrs per gene 
```{r}
# ------------------------------------------------------------------------------
# 1) (Re‐compute) or assume your isoform_summary exists. For illustration:
# ------------------------------------------------------------------------------
isoform_summary <- long_data %>%
  filter(
    !str_detect(gene_id, "BambuGene"),
    expression > 0
  ) %>%
  distinct(gene_id, transcript_id, .keep_all = TRUE) %>%
  group_by(gene_id) %>%
  summarise(
    n_isoforms = n_distinct(transcript_id),
    isoforms   = paste(sort(transcript_id), collapse = ", ")
  ) %>%
  ungroup() %>%
  arrange(desc(n_isoforms))

# (Optional) If you only want the top 10 genes:
top10_genes <- isoform_summary %>% slice_max(order_by = n_isoforms, n = 10)
top10_genes$isoforms <- NULL
# ------------------------------------------------------------------------------
# 2) Convert your data frame into a table grob:
#    You can either use tableGrob (gives more control) or grid.table (quick shortcut).
# ------------------------------------------------------------------------------
top10_genes

```

## subcatergoreis of Novel isoforms 
```{r}
long_data_novel <- long_data %>%
  filter( grepl("BambuTx", transcript_id) )

# 1. Deduplicate so each transcript_id only contributes once
long_unique <- long_data_novel %>%
  distinct(transcript_id, subcategory)

# 2. Count how many transcripts fall in each subcategory
subcat_counts <- long_unique %>%
  count(subcategory) %>%
  mutate(prop = n / sum(n))

# 3. Plot as a bar chart of proportions
ggplot(subcat_counts, aes(x = subcategory, y = prop)) +
  geom_col(fill = "steelblue") +
  scale_y_continuous(labels = scales::percent_format(1)) +
  labs(
    x = "Novel Isoform Subcategory",
    y = "Proportion of Transcripts",
    title = "Proportion of Each Novel Isoform Subcategory"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

# NUmber of novel isoforms in each cell type 

```{r}
iso_counts <- long_data_novel %>%
  distinct(transcript_id, cell_type, expression) %>%
  filter(expression > 0) %>%
  count(cell_type, name = "n_isoforms")

# 2. Bar‐plot
ggplot(iso_counts, aes(x = cell_type, y = n_isoforms)) +
  geom_col(fill = "steelblue") +
  labs(
    x     = "Cell Type",
    y     = "Number of Unique Isoforms",
    title = "Isoform Counts per Cell Type"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

### more retained introns in any catergory of cell type 
```{r}
# 1. Deduplicate so each transcript_id only counts once per celltype
long_unique <- long_data_novel %>%
  distinct(transcript_id, cell_type, structural_category, expression) %>% filter(expression > 1)

# 2. For each celltype, count how many unique isoforms fall in each subcategory
prop_df <- long_unique %>%
  group_by(cell_type) %>% 
  mutate(total_iso = n()) %>%        # total unique isoforms in this celltype
  ungroup() %>%
  group_by(cell_type, structural_category) %>%
  summarise(
    count = n(),                     # unique isoforms in this subcategory
    total = first(total_iso),        # carry along the total
    prop  = count / total            # proportion for this celltype
  ) %>%
  ungroup()

# 3. Sanity check: proportions sum to 1 *within* each celltype
prop_df %>% 
  group_by(cell_type) %>% 
  summarise(sum_prop = sum(prop))   # each should be 1

# 4. Plot
ggplot(prop_df, aes(x = structural_category, y = prop, fill = cell_type)) +
  geom_col(
    position = position_dodge(width = 0.8), 
    width    = 0.7
  ) +
  scale_y_continuous(labels = scales::percent_format(1)) +
  labs(
    x     = "Isoform Category",
    y     = "Proportion of Isoforms",
    title = "Novel Isoform Category Composition by Cell Type"
  ) +
  theme_minimal() +
  theme(
    axis.text.x   = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )


```



```{r}
# 1. Deduplicate so each transcript_id only counts once per celltype
long_unique <- long_data_novel %>%
  distinct(transcript_id, cell_type, subcategory, expression) %>% filter(expression > 1)

# 2. For each celltype, count how many unique isoforms fall in each subcategory
prop_df <- long_unique %>%
  group_by(cell_type) %>% 
  mutate(total_iso = n()) %>%        # total unique isoforms in this celltype
  ungroup() %>%
  group_by(cell_type, subcategory) %>%
  summarise(
    count = n(),                     # unique isoforms in this subcategory
    total = first(total_iso),        # carry along the total
    prop  = count / total            # proportion for this celltype
  ) %>%
  ungroup()

# 3. Sanity check: proportions sum to 1 *within* each celltype
prop_df %>% 
  group_by(cell_type) %>% 
  summarise(sum_prop = sum(prop))   # each should be 1

# 4. Plot
ggplot(prop_df, aes(x = subcategory, y = prop, fill = cell_type)) +
  geom_col(
    position = position_dodge(width = 0.8), 
    width    = 0.7
  ) +
  scale_y_continuous(labels = scales::percent_format(1)) +
  labs(
    x     = "Isoform Subcategory",
    y     = "Proportion of Isoforms",
    title = "Isoform Subcategory Composition by Cell Type"
  ) +
  theme_minimal() +
  theme(
    axis.text.x   = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )


```
###
Are there Cell type specific isoforms
Make it simple and go for a binary definition. presence or absence 

```{r}

# 1. Summarize per isoform × cell type as before
summary_tbl <- long_data %>%
  group_by(transcript_id, cell_type) %>%
  summarize(
    # number of cells with expression > 0
    n_cells    = sum(expression > 0),
    # total expression across those cells
    total_expr = sum(expression),
    # presence flag
    present    = n_cells > 0,
    .groups    = "drop"
  )

# 2. Identify isoforms present in exactly one cell type
specific_isoforms <- summary_tbl %>%
  filter(present) %>%                # keep only those detected
  group_by(transcript_id) %>%
  filter(n() == 1) %>%               # exactly one cell type
  ungroup() %>%
  dplyr::select(transcript_id, cell_type, n_cells, total_expr)

# 3. Pull back the gene symbol from your original data
gene_map <- long_data %>%
  dplyr::select(transcript_id, gene_id) %>%
  distinct()

# 4. Join it on
specific_isoforms <- specific_isoforms %>%
  left_join(gene_map, by = "transcript_id") %>%
  dplyr::select(transcript_id, gene_id, cell_type, n_cells, total_expr)

# 5. View your final table
specific_isoforms

```
```{r}
transcript_counts <- specific_isoforms %>%
  distinct(transcript_id, cell_type) %>%
  count(cell_type, name = "n_transcripts")

# 2. Bar‐plot
ggplot(transcript_counts, aes(x = cell_type, y = n_transcripts)) +
  geom_col(fill = "steelblue") +
  labs(
    x     = "Cell Type",
    y     = "Number of Unique Transcripts",
    title = "Unique Transcript per Cell Type"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```



Are Novel Isoforms more likely to be cell type specific?? 
```{r}

# Total number of specific isoforms
total_specific <- nrow(specific_isoforms)

# Number of those that are novel
novel_specific <- specific_isoforms %>%
  filter(grepl("BambuTx", transcript_id)) %>%
  nrow()

# And compute the percentage
percent_novel <- novel_specific / total_specific * 100

cat("percent novel:", percent_novel, "\n")
# 1) Flag “novel” vs “known” by transcript_id pattern
iso_flagged <- long_data %>%
  distinct(transcript_id) %>%
  mutate(
    is_novel = grepl("BambuTx", transcript_id)
  )

# 2) Determine cell-type specificity per transcript
presence_tbl <- long_data %>%
  group_by(transcript_id, cell_type) %>%
  summarize(present = any(expression > 0), .groups = "drop")

iso_specific <- presence_tbl %>%
  group_by(transcript_id) %>%
  summarize(
    n_ct       = sum(present),
    is_specific = n_ct == 1,
    .groups    = "drop"
  )

# 3) Combine flags into one summary table
iso_summary <- iso_flagged %>%
  inner_join(iso_specific, by = "transcript_id")

# 4) Build the 2×2 table
tbl <- table(
  Novel        = iso_summary$is_novel,
  Specific     = iso_summary$is_specific
)

# 5) Run Fisher’s exact test
fisher_res <- fisher.test(tbl)

# 6) View results
print(tbl)
print(fisher_res)



```

#####

Very significant effect. 
So ~8% novel isofroms in total, 
In terms of isofroms specific enrichment 11% of isofroms are novel 


### lets look at isoform specificity by cell clsuter. 

```{r}
# 1) For each transcript × cell_type, did we detect it at all?
presence_tbl <- long_data %>%
  group_by(transcript_id, cell_type) %>%
  summarize(present = any(expression > 0), .groups = "drop")

# 2) Count how many cell types each transcript appears in
nct_tbl <- presence_tbl %>%
  group_by(transcript_id) %>%
  summarize(n_celltypes = sum(present), .groups = "drop")

# 3) Tabulate frequencies of each n_celltypes
freq_tbl <- nct_tbl %>%
  count(n_celltypes, name = "n_isoforms") %>%
  filter(n_celltypes > 0) # there are 25 isofroms in this lsit whith expresstion = 0. have checked they do have 0 expresstion don't why theya re in the data

# 4) Plot
ggplot(freq_tbl, aes(x = factor(n_celltypes), y = n_isoforms)) +
  geom_col(fill = "grey") +
  geom_text(
    aes(label = n_isoforms),
    vjust = -0.3,                    # push labels just above bars
    size  = 3.5
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) +  # give headroom
  labs(
    x = "Number of Cell Types Detected In",
    y = "Number of Isoforms",
    title = "Distribution of Isoforms Found Across Cell Types", 
        caption = "Note: each isoform is counted once per cell type (expression > 0)."
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```


```{r}

# 3. Flag novel vs known by transcript_id pattern
nct_tbl <- nct_tbl %>%
  mutate(is_novel = grepl("BambuTx", transcript_id))

# 4. Tabulate counts of novel vs known within each n_celltypes
stacked_tbl <- nct_tbl %>%
  group_by(n_celltypes, is_novel) %>%
  summarize(n_isoforms = n(), .groups = "drop") %>%
  # ensure that known comes before novel in the legend
  mutate(is_novel = factor(is_novel, levels = c(FALSE, TRUE),
                           labels = c("known","novel")))

# Compute % novel per n_celltypes
pct_tbl <- stacked_tbl %>%
  group_by(n_celltypes) %>%
  summarize(
    total     = sum(n_isoforms),
    novel_ct  = sum(n_isoforms[is_novel=="novel"])
  ) %>%
  mutate(pct_novel = novel_ct / total * 100)

# Plot
ggplot(stacked_tbl, aes(x = factor(n_celltypes), y = n_isoforms, fill = is_novel)) +
  geom_col() +
  # % labels above each bar
  geom_text(
    data = pct_tbl,
    aes(
      x     = factor(n_celltypes),
      y     = total,
      label = sprintf("%.1f%%", pct_novel)
    ),
    vjust       = -0.5,
    inherit.aes = FALSE
  ) +
  scale_fill_manual(
    name   = "Isoform type",
    values = c("known" = "grey80", "novel" = "steelblue")
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
  labs(
    x     = "Number of Cell Types Detected In",
    y     = "Number of Isoforms",
    title = "Isoform Pervasiveness: Known vs Novel",
    caption = "Percentages show novel isoforms per group"
  ) +
  theme_minimal() +
  theme(
    axis.text.x     = element_text(angle = 45, hjust = 1),
    legend.position = "bottom",
    plot.caption    = element_text(size = 8, hjust = 0)
  )
```




```{r}
# 1–4: same data prep as before…
presence_tbl <- long_data %>%
  group_by(transcript_id, cell_type) %>%
  summarize(present = any(expression > 0), .groups = "drop")

nct_tbl <- presence_tbl %>%
  group_by(transcript_id) %>%
  summarize(n_celltypes = sum(present), .groups = "drop")

annot_tbl <- long_data %>%
  dplyr::select(transcript_id, exon_count, transcript_length, gc_content) %>%
  distinct()

grouped_iso <- nct_tbl %>%
  inner_join(annot_tbl, by = "transcript_id")

# 6. Boxplot — exon count by number of cell types (no outliers)
p_exons <- ggplot(grouped_iso, aes(x = factor(n_celltypes), y = exon_count)) +
  geom_boxplot(fill = "grey80", outlier.shape = NA) +
  labs(
    x     = "Detected in N Cell Types",
    y     = "Exon Count",
    title = "Exon Count by Cell-Type Pervasiveness"
  ) +
  theme_minimal() +
  ylim(0,10) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 7. Boxplot — transcript length (no outliers)
p_length <- ggplot(grouped_iso, aes(x = factor(n_celltypes), y = transcript_length)) +
  geom_boxplot(fill = "lightgreen", outlier.shape = NA) +
  labs(
    x     = "Detected in N Cell Types",
    y     = "Transcript Length (bp)",
    title = "Transcript Length by Cell-Type Pervasiveness"
  ) +
  theme_minimal() +
  ylim(0,7500) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 8. Boxplot — GC content (no outliers)
p_gc <- ggplot(grouped_iso, aes(x = factor(n_celltypes), y = gc_content)) +
  geom_boxplot(fill = "lightblue", outlier.shape = NA) +
  labs(
    x     = "Detected in N Cell Types",
    y     = "GC Content",
    title = "GC Content by Cell-Type Pervasiveness"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 9. Combine plots
(p_exons | p_length) / p_gc


```
How many novel exons do we find? 

```{r}
library(rtracklayer)
library(GenomicRanges)
library(dplyr)

#–– 1) build your full novel‐exon table ––#
get_novel_exon_table <- function(ref_gtf, qry_gtf, exon.type = "exon") {
  # import
  ref  <- import(ref_gtf);      ref_exons <- ref[ref$type == exon.type]
  qry  <- import(qry_gtf);      qry_exons <- qry[qry$type == exon.type]
  
  # union of known
  ref_union <- reduce(ref_exons)
  
  # pick novel query exons (no overlap with known union)
  novel_idx    <- which(!overlapsAny(qry_exons, ref_union))
  novel_exons  <- qry_exons[novel_idx]
  
  # build df of each interval + its gene & transcript
  df <- data.frame(
    seqnames      = as.character(seqnames(novel_exons)),
    start         = start(novel_exons),
    end           = end(novel_exons),
    strand        = as.character(strand(novel_exons)),
    gene_id       = mcols(novel_exons)$gene_id,
    transcript_id = mcols(novel_exons)$transcript_id,
    stringsAsFactors = FALSE
  )
  
  df %>%
    group_by(seqnames, start, end, strand) %>%
    summarise(
      gene_id       = paste(unique(gene_id), collapse=";"),
      transcript_id = paste(unique(transcript_id), collapse=";"),
      .groups = "drop"
    ) %>%
    as.data.frame()
}

#–– 2) count simply delegates to the table function ––#
count_novel_exons <- function(ref_gtf, qry_gtf, exon.type = "exon") {
  novel_table <- get_novel_exon_table(ref_gtf, qry_gtf, exon.type)
  nrow(novel_table)
}

# —— example usage —— #
ref_gtf <- "/data/scratch/users/yairp/FLAMES_Day55/resources/gencode.v47.annotation.gtf"
qry_gtf <- here("output","ref_file","filtered_for_sqanti.gtf")

# get table
novel_exon_table <- get_novel_exon_table(ref_gtf, qry_gtf)
# get count
n_count <- count_novel_exons(ref_gtf, qry_gtf)

# verify they match:
stopifnot(n_count == nrow(novel_exon_table))

# print out
cat("Found", n_count, "unique novel exon loci.\n")
head(novel_exon_table)


```

Are the novel exons specific to a cell type
